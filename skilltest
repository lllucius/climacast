#!/usr/bin/python3

# =============================================================================
#
# Copyright 2017 by Leland Lucius
#
# Released under the GNU Affero GPL
# See: https://github.com/lllucius/climocast/blob/master/LICENSE
#
# =============================================================================

import argparse
import array
import base64
import io
import itertools
import json
import os
import random
import re
import requests
import samplerate
import soundfile
import sys
import urllib.parse
import wave
import zlib
from bs4 import BeautifulSoup
from copy import deepcopy
from datetime import datetime
from requests_toolbelt import MultipartDecoder
from subprocess import Popen, PIPE, check_output
from urllib.parse import unquote_plus, quote_plus

VAR_RE = re.compile(r"(?P<var>{.*?})")
SUB_RE = re.compile(r"{(?P<var>.*?)\}[/\\]*")

SESS = requests.Session()
SESS.mount("https://", requests.adapters.HTTPAdapter(max_retries=0))

CFG = None

# Minimum required extra headers
HEADERS = \
{
    # Required for both login and API
    "Accept-Language": "en,*;q=0.1",
    # Must be a "known" user agent, otherwise we don't get a "session-id" cookie
    "User-Agent": "Links (2.14; CYGWIN_NT-10.0 2.6.1(0.305/5/3) x86_64; GNU C 5.4; text)"
}

def avs_recognize(wav):
    # make a copy of the headers
    headers = deepcopy(HEADERS)

    data = \
    {
        "messageHeader": 
        {
            "deviceContext": 
            [
                {
                    "name": "playbackState",
                    "namespace": "AudioPlayer",
                    "payload": 
                    {
                        "streamId": "",
                        "offsetInMilliseconds": 0,
                        "playerActivity": "IDLE"
                    }
                }
            ]
        },
        "messageBody": 
        {
            "profile": "alexa-close-talk",
            "locale": "en-us",
            "format": "audio/L16; rate=16000; channels=1"
        }
    }

    files = \
    [
        ( 
            "request",
            (
                "request",
                json.dumps(data),
                "application/json; charset=UTF-8",
            )
        ),
        (
            "audio",
            (
                "audio",
                wav,
                "audio/L16; rate=16000; channels=1"
            )
        )
    ]

    headers["Authorization"] = "Bearer %s" % CFG["avs"]["access"]

    wav.seek(0)
    url = "https://access-alexa-na.amazon.com/v1/avs/speechrecognizer/recognize"
    r = requests.post(url, headers=headers, files=files)

    # Possibly refresh token and retry
    if r.status_code == 403:
        headers["Authorization"] = "Bearer %s" % avs_refresh()
        r = requests.post(url, headers=headers, files=files)

    # If the request fails, retry
    if r.status_code != 200:
        print(r.status_code)
        for header in r.headers:
            print("HEADER:", header, ":", r.headers[header])
        print(r.content)
        print("WAV POS B4", wav.tell())
        print(files)
        print(wav.seek(0, 2))
        print("WAV LEN", wav.tell())
        wav.seek(0)
        r = requests.post(url, headers=headers, files=files)

    try:
        for part in MultipartDecoder.from_response(r).parts:
            if part.headers[b"Content-Type"] == b"audio/mpeg":
                return part.content
    except:
        pass

    print(r.status_code)
    for header in r.headers:
        print(header, ":", r.headers[header])
    print(r.content)

    return None

def avs_refresh():
    # make a copy of the headers
    headers = deepcopy(HEADERS)

    data = \
        {
            "client_id": CFG["avs"]["clientid"],
            "client_secret": CFG["avs"]["secret"],
            "refresh_token": CFG["avs"]["refresh"],
            "grant_type": "refresh_token"
        }

    r = SESS.post("https://api.amazon.com/auth/o2/token", headers=headers, data=data)
    data = r.json()
    CFG["avs"]["access"] = data["access_token"]
    CFG["avs"]["refresh"] = data["refresh_token"]
    with open(ARGS.config, "w") as c:
        json.dump(CFG, c, indent=4)

    return CFG["avs"]["access"]

def avs_auth():
    # Make a copy of the headers
    headers = deepcopy(HEADERS)

    # Manually handle redirection so we can detect redirection to our (dummy) URL
    def redirect_to(resp):
        target = SESS.get_redirect_target(resp)
        while target is not None:
            if target.startswith(CFG["avs"]["redirect"]):
                query = urllib.parse.parse_qs(urllib.parse.urlparse(target).query)
                return resp, query["code"][0] if "code" in query else None
            resp =  SESS.get(target, headers=headers, allow_redirects=False)
            target = SESS.get_redirect_target(resp)
        return resp, None

    scope_data = \
    {
        "alexa:all":
        {
            "productID": CFG["avs"]["deviceid"],
            "productInstanceAttributes":
            {
                "deviceSerialNumber": "001"
            }
        }
    }

    data = \
    {
        "client_id": CFG["avs"]["clientid"],
        "scope": "alexa:all",
        "scope_data": json.dumps(scope_data),
        "response_type": "code",
        "redirect_uri": CFG["avs"]["redirect"]
    }

    code = None

    # Refrieve the login page
    r = SESS.get("https://www.amazon.com/ap/oa", headers=headers, params=data)

    # Extract the form fields
    form = BeautifulSoup(r.text, "html.parser").find("form", {"name": "acknowledgement-form"})
    if form is not None:
        data = {}
        for field in form.find_all("input"):
            if "name" in field.attrs and "value" in field.attrs:
                data[field.attrs["name"]] = field.attrs["value"]

        # Approve it
        data["acknowledgementApproved"] = ""

        # Needed for login success
        headers["Referer"] = r.request.url

        # Post it.  Do not need to redirect here since the response has all we need
        r = SESS.get(form.attrs["action"], params=data, headers=headers, allow_redirects=False)
        r, code = redirect_to(r)

    if code is None:
        # Extract the form fields
        form = BeautifulSoup(r.text, "html.parser").find("form", {"name": "signIn"})
        if form is not None:
            data = {}
            for field in form.find_all("input"):
                if "name" in field.attrs and "value" in field.attrs:
                    data[field.attrs["name"]] = field.attrs["value"]

            # Set the email and password
            data["email"] = CFG["email"]
            data["password"] = CFG["password"]

            # Needed for login success
            SESS.cookies["ap-fid"] = '""'
            headers["Referer"] = r.request.url

            # Post it.
            r = SESS.post(form.attrs["action"], data=data, headers=headers, allow_redirects=False)
            r, code = redirect_to(r)

    if code is None:
        form = BeautifulSoup(r.text, "html.parser").find("form", {"name": "consent-form"})
        if form is not None:
            data = {}
            for field in form.find_all("input"):
                if "name" in field.attrs and "value" in field.attrs:
                    data[field.attrs["name"]] = field.attrs["value"]

            # Approve it
            data["consentApproved"] = ""

            # Needed for login success
            headers["Referer"] = r.request.url

            # Post it.  Do not need to redirect here since the response has all we need
            r = SESS.get(form.attrs["action"], params=data, headers=headers, allow_redirects=False)
            r, code = redirect_to(r)

    data = \
    {
        "client_id": CFG["avs"]["clientid"],
        "client_secret": CFG["avs"]["secret"],
        "code": code,
        "grant_type": "authorization_code",
        "redirect_uri": CFG["avs"]["redirect"]
    }

    r = SESS.post("https://api.amazon.com/auth/o2/token", headers=headers, data=data)
    data = r.json()
    CFG["avs"]["access"] = data["access_token"]
    CFG["avs"]["refresh"] = data["refresh_token"]
    with open(".config", "w") as c:
        json.dump(CFG, c, indent=4)

def login():
    # Make a copy of the headers
    headers = deepcopy(HEADERS)

    # Start at the developer home page
    base = "https://developer.amazon.com"
    r = SESS.get(base, headers=headers)

    # Click the Extract the form fields
    login = BeautifulSoup(r.text, "html.parser").find("a", text="Sign In")
    if not login:
        print("Login to developer site failed")
        quit()
        
    # Refrieve the login page
    r = SESS.get(urllib.parse.urljoin(base, login["href"]), headers=headers)
    
    # Extract the form fields
    form = BeautifulSoup(r.text, "html.parser").find("form", {"name": "signIn"})
    data = {}
    for field in form.find_all("input"):
        if "name" in field.attrs and "value" in field.attrs:
            data[field.attrs["name"]] = field.attrs["value"]

    # Set the email and password
    data["email"] = CFG["email"]
    data["password"] = CFG["password"]

    # Needed for login success
    SESS.cookies["ap-fid"] = '""'
    headers["Referer"] = r.request.url

    # Post it.  Do not need to redirect here since the response has all we need
    r = SESS.post(form.attrs["action"], data=data, headers=headers, allow_redirects=False)

def api(data, tts=False):
    # Copy the headers and add API required extras
    headers = deepcopy(HEADERS)    
    headers["Accept"] = "application/json"
    headers["Content-Type"] = "application/x-www-form-urlencoded"
    headers["x-amz-csrf"] = SESS.cookies["session-id"]

    # Generate the URL
    url = "https://developer.amazon.com/edw/ajax/%s" % \
          ("getTTS" if tts else "invokeSkillWithText")

    # Invoke the API
    r = SESS.post(url, data=quote_plus(json.dumps(data)), headers=headers)

    return json.loads(unquote_plus(r.text))

def sapiTTS(text):
    if sys.platform == "win32":
        # We want 16kHz, 16-bit, mono audio
        afmt = CreateObject("sapi.SpAudioFormat")
        afmt.Type = SpeechLib.SAFT16kHz16BitMono

        # Output audio goes to a memory stream
        strm = CreateObject("sapi.SpMemoryStream")
        strm.Format = afmt

        # Create the voice (uses the default system voice)
        spkr = CreateObject("sapi.SpVoice")
        spkr.AllowOutputFormatChangesOnNextSet = False
        spkr.AudioOutputStream = strm
        spkr.Speak(text)

        return array.array("h", bytes(strm.GetData()));

    # Get powershell up and running
    p = Popen("powershell.exe -NonInteractive -File -", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, universal_newlines=False, cwd="/mnt/c")

    # Create the powershell commands
    cmd = """
          add-Type -AssemblyName System.Speech;
          add-Type -AssemblyName System.IO;
          $fmt = New-Object System.Speech.AudioFormat.SpeechAudioFormatInfo(16000, [System.Speech.AudioFormat.AudioBitsPerSample]::Sixteen, [System.Speech.AudioFormat.AudioChannel]::Mono);
          $wav = New-Object System.IO.MemoryStream;
          $synth = New-Object System.Speech.Synthesis.SpeechSynthesizer;
          $synth.SetOutputToAudioStream($wav, $fmt);
          $synth.Speak('%s');
          [Console]::Error.Write([System.convert]::ToBase64String($wav.ToArray()));
          $synth.Dispose();
          $wav.Dispose();
          exit;
          """ % text.replace("'", "''")

    # Send them and get the response from stderr
    out = p.communicate(bytes(cmd, "UTF-8"))[1]

    return array.array("h", base64.b64decode(out.decode("UTF-8")))

def espeakTTS(text):
    p = Popen("espeak -v en+m2 --stdin --stdout", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)

    out = p.communicate(bytes(text, "UTF-8"))[0]
    raw, rate = soundfile.read(io.BytesIO(out))
    return samplerate.resample(raw, 16000.0 / rate, "sinc_best")

def amazonTTS(text):
    speak = '<speak><prosody rate="90%%" pitch="-20%%">%s</prosody></speak>' % text
    data = {"audioFormat": "OGG",
            "contentType": "SSML",
            "text": base64.b64encode(bytes(speak, "UTF-8")).decode("UTF-8"),
            "voiceName": "en_us_nina"}

    out = base64.b64decode(api(data, True)["audioFiles"][0])
    raw, rate = soundfile.read(io.BytesIO(out))
    return samplerate.resample(raw, 16000.0 / rate, "sinc_best")

def tts(text):
    if CFG["ttsmethod"] == "amazon":
        return amazonTTS(text)
    elif CFG["ttsmethod"] == "espeak":
        return espeakTTS(text)
    elif CFG["ttsmethod"] == "sapi":
        return sapiTTS(text)

    return ""

def test_utterance(utterance, types):
    print()
    print("Testing:", utterance)
    last = 0
    toapi = ""
    totts = ""
    for match in VAR_RE.finditer(utterance):
        val = types[match.group(0)]
        toapi += utterance[last:match.start()] + val
        if val.isdigit():
            val = " ".join(list(val))
        totts += utterance[last:match.start()] + val
        last = match.end()

    toapi += utterance[last:]
    totts += utterance[last:]

    toapi = utterance if len(toapi) == 0 else toapi
    totts = utterance if len(totts) == 0 else totts

    print("With:", toapi)
    outpfx = os.path.join(CFG["resultsdir"], "%s" % toapi.replace(" ", "_").replace("'", ""))
     
    if CFG["generaterr"]:
        data = {"endpointRegion": "NA",
                "text": toapi,
                "applicationId": "amzn1.ask.skill.2644f17f-64e8-4e53-8dea-a36b2a1d8fc1",
                "locale": "en_US",
                "session": None}

        print("Calling skill simulator")
        page = api(data)
        page["_utterance"] = toapi
        with open(outpfx + ".txt", "w") as f:
            json.dump(page, f, indent=4)

    if CFG["callavs"]:
        print("Converting text to speech")
        raw = tts("alexa ask climocast %s" % totts)

        # Save the file
        soundfile.write(outpfx + ".wav", raw, 16000, format="WAV")

        # Create the input audio stream
        wav = io.BytesIO()
        soundfile.write(wav, raw, 16000, format="WAV")
        wav.seek(0)

        # Send converted file to AVS
        print("Calling Alexa Voice Service")
        with open(outpfx + ".mp3", "wb") as out:
            out.write(avs_recognize(wav))

def test_json(name):
    def get_values(instr):
        vals = []

        temp = ""
        last = 0
        for match in SUB_RE.finditer(instr):
            var = match.group(1)
            if var == "skilldir":
                val = CFG["skilldir"] + os.path.sep
            elif var == "testsdir":
                val = CFG["testsdir"] + os.path.sep
            else:
                val = match.group(0)
            temp += instr[last:match.start()] + val
            last = match.end()
        instr = temp + instr[last:]

        if instr.startswith("file:"):
            path, _, regex = instr[5:].partition(",")
            with open(path) as f:
                for line in f.readlines():
                    line = line.strip()
                    if not line.startswith("#") and len(line) > 0:
                        if regex == "" or re.match(regex, line):
                            vals.append(line)
        elif instr.startswith("utter:"):
            path, _, regex = instr[6:].partition(",")
            with open(path) as f:
                for line in f.readlines():
                    _, _, utter = line.partition(" ")
                    utter = utter.strip()
                    if utter != "":
                        if regex == "" or re.match(regex, line):
                            vals.append(utter)
        elif instr.startswith("exec:"):
            out = check_output(instr[5:], shell=True).decode("UTF-8").replace("\r\n", "\n").replace("\r", "\n").split("\n")
            for instr in out:
                if instr != "":
                    vals.append(instr)
        elif instr.startswith("random:"):
            parms = instr[7:].split(",")
            path = parms[0]
            cnt = parms[1]
            regex = parms[2] if len(parms) > 2 else r".*"
            with open(path) as f:
                lines = []
                for line in f.readlines():
                    line = line.strip()
                    if not line.startswith("#") and len(line) > 0:
                        if re.match(regex, line):
                            lines.append(line)
                
                vals = random.sample(lines, int(cnt))
        else:
            vals.append(instr)

        return vals

    with open(os.path.join(CFG["testsdir"], name)) as f:
        print()
        print("Test:", name)
        test = json.load(f)

        types = {}
        for name in test.get("types", {}):
            typename = "{%s}" % name
            types[typename] = []
            for val in test["types"][name]:
                types[typename] += get_values(val)

        for val in test["utterances"]:
            for utterance in get_values(val):
                typenames = VAR_RE.findall(utterance)

                iterables = []
                for typename in typenames:
                    iterables.append(types[typename])

                for iterable in itertools.product(*iterables):
                    t = {}
                    ndx = 0
                    for typename in typenames:
                        t[typename] = iterable[ndx]
                        ndx += 1
                    test_utterance(utterance, t)

parser = argparse.ArgumentParser(description='Alexa Skill Tester')
parser.add_argument("file", nargs="*",
                   help="name of test file")
parser.add_argument("-c", "--config", default="./.config",
                   help="path to configuration file (default is ./.config")

ARGS = parser.parse_args()
try:
    with open(ARGS.config, "r") as c:
        CFG = json.load(c)
except:
    print("Couldn't open config file:", ARGS.config)
    quit()

if CFG is None:
    print("no config")
    quit()

if CFG["ttsmethod"] == "sapi" and sys.platform == "win32":
    from comtypes.client import CreateObject
    from comtypes.gen import SpeechLib

if CFG["callavs"]:
    if CFG["avs"].get("access", "") == "":
        avs_auth()

if (CFG["callavs"] and CFG["ttsmethod"] == "amazon") or CFG["generaterr"]:
    login()

if len(ARGS.file) > 0:
    for name in ARGS.file:
        test_json(name)
else:
    for name in os.listdir(CFG["testsdir"]):
        if name.startswith("test_"):
            test_json(name)


